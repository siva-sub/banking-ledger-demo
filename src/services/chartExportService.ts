import dayjs from 'dayjs';

// Export configuration interfaces
export interface ExportConfig {
  format: 'csv' | 'excel' | 'json' | 'png' | 'svg' | 'pdf';
  filename?: string;
  quality?: number;
  width?: number;
  height?: number;
  includeMetadata?: boolean;
  compression?: boolean;
}

export interface ChartExportData {
  chartType: string;
  title: string;
  data: any[];
  config: any;
  timestamp: string;
  metadata: {
    filters: any;
    dateRange: [string, string];
    generatedBy: string;
    version: string;
  };
}

export interface ExportResult {
  success: boolean;
  filename: string;
  format: string;
  size: number;
  error?: string;
  downloadUrl?: string;
}

class ChartExportService {
  private readonly version = '1.0.0';
  private readonly maxFileSize = 50 * 1024 * 1024; // 50MB limit

  // Export chart data in various formats
  async exportChartData(
    chartData: ChartExportData,
    config: ExportConfig
  ): Promise<ExportResult> {
    try {
      const timestamp = dayjs().format('YYYY-MM-DD_HH-mm-ss');
      const filename = config.filename || `${chartData.chartType}_${timestamp}.${config.format}`;
      
      let blob: Blob;
      let mimeType: string;
      
      switch (config.format) {
        case 'csv':
          blob = this.exportToCSV(chartData, config);
          mimeType = 'text/csv';
          break;
        case 'excel':
          blob = this.exportToExcel(chartData, config);
          mimeType = 'application/vnd.ms-excel';
          break;
        case 'json':
          blob = this.exportToJSON(chartData, config);
          mimeType = 'application/json';
          break;
        case 'png':
          blob = await this.exportToPNG(chartData, config);
          mimeType = 'image/png';
          break;
        case 'svg':
          blob = await this.exportToSVG(chartData, config);
          mimeType = 'image/svg+xml';
          break;
        case 'pdf':
          blob = await this.exportToPDF(chartData, config);
          mimeType = 'application/pdf';
          break;
        default:
          throw new Error(`Unsupported format: ${config.format}`);
      }
      
      if (blob.size > this.maxFileSize) {
        throw new Error(`File size ${blob.size} exceeds maximum limit of ${this.maxFileSize}`);
      }
      
      const downloadUrl = URL.createObjectURL(blob);
      this.downloadFile(downloadUrl, filename);
      
      return {
        success: true,
        filename,
        format: config.format,
        size: blob.size,
        downloadUrl
      };
    } catch (error) {
      return {
        success: false,
        filename: '',
        format: config.format,
        size: 0,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  // Export to CSV format
  private exportToCSV(chartData: ChartExportData, config: ExportConfig): Blob {
    const { data, metadata } = chartData;
    
    if (!data || data.length === 0) {
      throw new Error('No data available for export');
    }
    
    const headers = Object.keys(data[0]);
    const csvLines: string[] = [];
    
    // Add metadata if requested
    if (config.includeMetadata) {
      csvLines.push('# Chart Export Metadata');
      csvLines.push(`# Generated: ${chartData.timestamp}`);
      csvLines.push(`# Chart Type: ${chartData.chartType}`);
      csvLines.push(`# Title: ${chartData.title}`);
      csvLines.push(`# Date Range: ${metadata.dateRange[0]} to ${metadata.dateRange[1]}`);
      csvLines.push(`# Generated By: ${metadata.generatedBy}`);
      csvLines.push(`# Version: ${metadata.version}`);
      csvLines.push('');
    }
    
    // Add headers
    csvLines.push(headers.join(','));
    
    // Add data rows
    data.forEach(row => {
      const csvRow = headers.map(header => {
        const value = row[header];
        if (value === null || value === undefined) return '';
        if (typeof value === 'string' && (value.includes(',') || value.includes('"'))) {
          return `"${value.replace(/"/g, '""')}"`;
        }
        return String(value);
      }).join(',');
      csvLines.push(csvRow);
    });
    
    return new Blob([csvLines.join('\n')], { type: 'text/csv;charset=utf-8;' });
  }

  // Export to Excel format (TSV for simplicity)
  private exportToExcel(chartData: ChartExportData, config: ExportConfig): Blob {
    const { data, metadata } = chartData;
    
    if (!data || data.length === 0) {
      throw new Error('No data available for export');
    }
    
    const headers = Object.keys(data[0]);
    const tsvLines: string[] = [];
    
    // Add metadata sheet
    if (config.includeMetadata) {
      tsvLines.push('Chart Export Metadata');
      tsvLines.push(`Generated\t${chartData.timestamp}`);
      tsvLines.push(`Chart Type\t${chartData.chartType}`);
      tsvLines.push(`Title\t${chartData.title}`);
      tsvLines.push(`Date Range\t${metadata.dateRange[0]} to ${metadata.dateRange[1]}`);
      tsvLines.push(`Generated By\t${metadata.generatedBy}`);
      tsvLines.push(`Version\t${metadata.version}`);
      tsvLines.push('');
      tsvLines.push('Data:');
    }
    
    // Add headers
    tsvLines.push(headers.join('\t'));
    
    // Add data rows
    data.forEach(row => {
      const tsvRow = headers.map(header => {
        const value = row[header];
        if (value === null || value === undefined) return '';
        return String(value);
      }).join('\t');
      tsvLines.push(tsvRow);
    });
    
    return new Blob([tsvLines.join('\n')], { type: 'application/vnd.ms-excel' });
  }

  // Export to JSON format
  private exportToJSON(chartData: ChartExportData, config: ExportConfig): Blob {
    const exportData = {
      ...(config.includeMetadata && { metadata: chartData.metadata }),
      chartType: chartData.chartType,
      title: chartData.title,
      timestamp: chartData.timestamp,
      data: chartData.data,
      config: chartData.config
    };
    
    const jsonString = JSON.stringify(exportData, null, 2);
    return new Blob([jsonString], { type: 'application/json' });
  }

  // Export to PNG format
  private async exportToPNG(chartData: ChartExportData, config: ExportConfig): Promise<Blob> {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d')!;
    
    canvas.width = config.width || 800;
    canvas.height = config.height || 600;
    
    // Fill background
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Add title
    ctx.fillStyle = '#000000';
    ctx.font = '24px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(chartData.title, canvas.width / 2, 40);
    
    // Add timestamp
    ctx.font = '12px Arial';
    ctx.fillText(`Generated: ${chartData.timestamp}`, canvas.width / 2, canvas.height - 20);
    
    // For actual chart rendering, we'd need to integrate with the chart library
    // This is a placeholder that shows the concept
    ctx.fillStyle = '#1890ff';
    ctx.fillRect(50, 80, canvas.width - 100, canvas.height - 160);
    
    ctx.fillStyle = '#ffffff';
    ctx.font = '16px Arial';
    ctx.fillText('Chart visualization would be rendered here', canvas.width / 2, canvas.height / 2);
    
    return new Promise((resolve) => {
      canvas.toBlob((blob) => {
        resolve(blob!);
      }, 'image/png', config.quality || 1.0);
    });
  }

  // Export to SVG format
  private async exportToSVG(chartData: ChartExportData, config: ExportConfig): Promise<Blob> {
    const width = config.width || 800;
    const height = config.height || 600;
    
    const svgContent = `
      <svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
        <style>
          .title { font-family: Arial, sans-serif; font-size: 24px; font-weight: bold; }
          .timestamp { font-family: Arial, sans-serif; font-size: 12px; fill: #666; }
          .placeholder { font-family: Arial, sans-serif; font-size: 16px; fill: #ffffff; }
        </style>
        
        <!-- Background -->
        <rect width="100%" height="100%" fill="#ffffff"/>
        
        <!-- Title -->
        <text x="${width / 2}" y="40" text-anchor="middle" class="title">${chartData.title}</text>
        
        <!-- Chart placeholder -->
        <rect x="50" y="80" width="${width - 100}" height="${height - 160}" fill="#1890ff"/>
        <text x="${width / 2}" y="${height / 2}" text-anchor="middle" class="placeholder">
          Chart visualization would be rendered here
        </text>
        
        <!-- Timestamp -->
        <text x="${width / 2}" y="${height - 20}" text-anchor="middle" class="timestamp">
          Generated: ${chartData.timestamp}
        </text>
      </svg>
    `;
    
    return new Blob([svgContent], { type: 'image/svg+xml' });
  }

  // Export to PDF format (simplified)
  private async exportToPDF(chartData: ChartExportData, config: ExportConfig): Promise<Blob> {
    // This is a simplified PDF export - in a real implementation,
    // you'd use a library like jsPDF or PDFKit
    const pdfContent = `
      %PDF-1.4
      1 0 obj
      <<
        /Type /Catalog
        /Pages 2 0 R
      >>
      endobj
      
      2 0 obj
      <<
        /Type /Pages
        /Kids [3 0 R]
        /Count 1
      >>
      endobj
      
      3 0 obj
      <<
        /Type /Page
        /Parent 2 0 R
        /MediaBox [0 0 612 792]
        /Contents 4 0 R
      >>
      endobj
      
      4 0 obj
      <<
        /Length 100
      >>
      stream
      BT
      /F1 12 Tf
      72 720 Td
      (${chartData.title}) Tj
      0 -20 Td
      (Generated: ${chartData.timestamp}) Tj
      ET
      endstream
      endobj
      
      xref
      0 5
      0000000000 65535 f
      0000000009 00000 n
      0000000074 00000 n
      0000000120 00000 n
      0000000179 00000 n
      trailer
      <<
        /Size 5
        /Root 1 0 R
      >>
      startxref
      380
      %%EOF
    `;
    
    return new Blob([pdfContent], { type: 'application/pdf' });
  }

  // Download file helper
  private downloadFile(url: string, filename: string): void {
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    link.style.display = 'none';
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // Clean up the URL after a delay
    setTimeout(() => {
      URL.revokeObjectURL(url);
    }, 1000);
  }

  // Export multiple charts as a bundle
  async exportMultipleCharts(
    charts: ChartExportData[],
    config: ExportConfig
  ): Promise<ExportResult> {
    try {
      const timestamp = dayjs().format('YYYY-MM-DD_HH-mm-ss');
      const filename = config.filename || `charts_bundle_${timestamp}.zip`;
      
      // For simplicity, we'll create a JSON bundle
      // In a real implementation, you'd create a proper ZIP file
      const bundleData = {
        exportDate: dayjs().toISOString(),
        charts: charts.map(chart => ({
          chartType: chart.chartType,
          title: chart.title,
          data: chart.data,
          metadata: chart.metadata
        }))
      };
      
      const jsonString = JSON.stringify(bundleData, null, 2);
      const blob = new Blob([jsonString], { type: 'application/json' });
      
      const downloadUrl = URL.createObjectURL(blob);
      this.downloadFile(downloadUrl, filename);
      
      return {
        success: true,
        filename,
        format: 'json',
        size: blob.size,
        downloadUrl
      };
    } catch (error) {
      return {
        success: false,
        filename: '',
        format: 'json',
        size: 0,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  // Get export format capabilities
  getExportCapabilities(): {
    formats: string[];
    maxFileSize: number;
    supportedChartTypes: string[];
  } {
    return {
      formats: ['csv', 'excel', 'json', 'png', 'svg', 'pdf'],
      maxFileSize: this.maxFileSize,
      supportedChartTypes: [
        'line',
        'column',
        'pie',
        'area',
        'scatter',
        'heatmap',
        'gauge',
        'treemap',
        'waterfall',
        'sankey',
        'boxplot'
      ]
    };
  }

  // Validate export configuration
  validateExportConfig(config: ExportConfig): {
    valid: boolean;
    errors: string[];
  } {
    const errors: string[] = [];
    
    if (!config.format) {
      errors.push('Format is required');
    } else if (!this.getExportCapabilities().formats.includes(config.format)) {
      errors.push(`Unsupported format: ${config.format}`);
    }
    
    if (config.quality && (config.quality < 0 || config.quality > 1)) {
      errors.push('Quality must be between 0 and 1');
    }
    
    if (config.width && config.width < 100) {
      errors.push('Width must be at least 100 pixels');
    }
    
    if (config.height && config.height < 100) {
      errors.push('Height must be at least 100 pixels');
    }
    
    return {
      valid: errors.length === 0,
      errors
    };
  }
}

// Export singleton instance
export const chartExportService = new ChartExportService();
export default chartExportService;